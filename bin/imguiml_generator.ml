open GoblintCil

let filename = Sys.argv.(1)
let types_output = Sys.argv.(2)
let enums_output = Sys.argv.(3)
let base_structs_output = Sys.argv.(4)
let structs_output = Sys.argv.(5)

let abstract_structs =
  [ "DockRequest"; "DockNodeSettings"; "TableColumnSortSpecs"; "Context" ]

module Strs = Set.Make (String)

let defined = ref Strs.empty
let current_struct = ref ""

let pp_header fmt =
  let time = Unix.gmtime (Unix.time ()) in
  Format.fprintf fmt
    "(* This file was generated by imguiml_generator.exe on %02d/%02d/%04d at \
     %02d:%02d:%02d *)\n"
    time.tm_mday time.tm_mon (time.tm_year + 1900) time.tm_hour time.tm_min
    time.tm_sec

let pp_prolog fmt =
  Format.fprintf fmt
    {ocaml|
let int_as_uchar =
  view ~read:Unsigned.UChar.to_int
       ~write:Unsigned.UChar.of_int
       uchar

let int_as_ushort =
  view ~read:Unsigned.UShort.to_int
       ~write:Unsigned.UShort.of_int
       ushort

let int_as_uint =
  view ~read:Unsigned.UInt.to_int
       ~write:Unsigned.UInt.of_int
       uint

let int_as_ulong =
  view ~read:Unsigned.ULong.to_int
       ~write:Unsigned.ULong.of_int
       ulong

let int_as_ullong =
  view ~read:Unsigned.ULLong.to_int
       ~write:Unsigned.ULLong.of_int
       ullong

let int_as_sint =
  view ~read:Signed.SInt.to_int
       ~write:Signed.SInt.of_int
       sint

let int_as_sllong =
  view ~read:Signed.LLong.to_int
       ~write:Signed.LLong.of_int
       llong

let int_as_size_t =
  view ~read:Unsigned.Size_t.to_int
       ~write:Unsigned.Size_t.of_int
       size_t

let bool =
  view ~read:(fun u -> Unsigned.UChar.(compare u zero <> 0))
       ~write:(fun b -> Unsigned.UChar.(of_int (Stdlib.compare b false)))
       uchar

type file_t
let file_t : file_t structure typ = typedef (structure "FILE") "FILE"

let (>>) a b = a lsr b

|ocaml}

let replacements =
  List.map
    (fun (reg, rep) -> (Str.regexp reg, rep))
    [
      ("IO", "Io");
      ("ImGui", "Im");
      ("ID", "Id");
      ("COUNT", "count");
      ("BEGIN", "Begin");
      ("END", "End");
      ("OSX", "Osx");
      ("SIZE", "Size");
      ("OFFSET", "Offset");
      ("SRGB", "Srgb");
      ("HDR", "Hdr");
      ("TTY", "Tty");
      ("FILE", "File");
      ("STB", "Stb");
    ]

let camlCase_to_snake_case str =
  let str =
    List.fold_left
      (fun str (reg, rep) -> Str.global_replace reg rep str)
      str replacements
  in
  let buffer = Buffer.create @@ (2 * String.length str) in
  let _ =
    String.fold_left
      (fun acc c ->
        match c with
        | 'A' .. 'Z' ->
            if not acc then Buffer.add_char buffer '_';
            Buffer.add_char buffer (Char.lowercase_ascii c);
            false
        | '_' ->
            Buffer.add_char buffer '_';
            true
        | _ ->
            Buffer.add_char buffer c;
            false)
      false str
  in
  Buffer.contents buffer

let mangle_name name =
  match name with
  | "size_t" -> "size_t"
  | _ ->
      let no_im =
        if String.starts_with ~prefix:"ImGui" name then
          String.sub name 5 (String.length name - 5)
        else if String.starts_with ~prefix:"Im" name then
          String.sub name 2 (String.length name - 2)
        else name
      in
      let no_im =
        List.fold_left
          (fun no_im (base, replacement) ->
            Str.global_replace base replacement no_im)
          no_im replacements
      in
      let str = camlCase_to_snake_case no_im in
      String.sub str 1 (String.length str - 1) ^ "_t"

let mangle_field_name name =
  let name =
    List.fold_left
      (fun name (reg, rep) -> Str.global_replace reg rep name)
      name replacements
  in
  let str = camlCase_to_snake_case name in
  let str =
    if str.[0] = '_' then String.sub str 1 (String.length str - 1) else str
  in
  match str with "type" -> "type_" | _ -> str

let mangle_struct_name name =
  let name =
    List.fold_left
      (fun name (reg, rep) -> Str.global_replace reg rep name)
      name replacements
  in
  if String.starts_with ~prefix:"Im" name then
    String.sub name 2 (String.length name - 2)
  else name

let mangle_enum_variant regexp name =
  let name = Str.global_replace regexp "" name in
  let name =
    if String.starts_with ~prefix:"_" name then
      String.sub name 1 (String.length name - 1)
    else name
  in
  match name.[0] with '0' .. '9' -> "K" ^ name | _ -> name

let pp_ocaml_arrow fmt () = Format.fprintf fmt "@ ->@ "
let pp_ctypes_arrow fmt () = Format.fprintf fmt "@ @->@ "

let pp_exp fmt exp =
  let doc = Cil.printExp Cil.defaultCilPrinter () exp in
  Format.fprintf fmt "%s" (Pretty.sprint ~width:80 doc)

let enum_module_name ename =
  let ename =
    let prefix_regexp = Str.regexp "__anonenum_" in
    let suffix_regexp = Str.regexp "[0-9]+$" in
    Str.global_replace prefix_regexp "" ename
    |> Str.global_replace suffix_regexp ""
  in
  let ename_no_ =
    if String.ends_with ~suffix:"_" ename then
      String.sub ename 0 (String.length ename - 1)
    else ename
  in
  if String.starts_with ~prefix:"ImGui" ename_no_ then
    String.sub ename_no_ 5 (String.length ename_no_ - 5)
  else if String.starts_with ~prefix:"Im" ename_no_ then
    String.sub ename_no_ 2 (String.length ename_no_ - 2)
  else ename_no_

let rec pp_ctypes_type ~lift ~mod_name fmt = function
  | TVoid _ -> Format.fprintf fmt "void"
  | TInt (ikind, _) ->
      Format.fprintf fmt
        (match ikind with
        | IInt -> "int"
        | IShort -> "short"
        | ISChar -> "schar"
        | IBool -> "bool"
        | IChar -> "char"
        | IUInt ->
            if lift then "@[<hov>(lift_typ@ int_as_uint)@]" else "int_as_uint"
        | IUShort ->
            if lift then "@[<hov>(lift_typ@ int_as_ushort)@]"
            else "int_as_ushort"
        | IUChar ->
            if lift then "@[<hov>(lift_typ@ int_as_uchar)@]" else "int_as_uchar"
        | _ -> "int_TODO")
  | TFloat _ -> Format.fprintf fmt "float"
  | TPtr (typ, _) -> (
      match typ with
      | TInt (IChar, _) -> Format.fprintf fmt "string"
      | TFun _ ->
          if lift then
            Format.fprintf fmt "@[<hov 2>(lift_typ@ (Foreign.funptr@ %a))@]"
              (pp_ctypes_type ~lift:true ~mod_name)
              typ
          else
            Format.fprintf fmt "@[<hov 2>(Foreign.funptr@ %a)@]"
              (pp_ctypes_type ~lift ~mod_name)
              typ
      | _ ->
          Format.fprintf fmt "@[<hov>(ptr@ %a)@]"
            (pp_ctypes_type ~lift ~mod_name)
            typ)
  | TArray (typ, size, _) -> (
      match size with
      | Some size ->
          Format.fprintf fmt "@[<hov>(array@ (%a)@ %a)@]" pp_exp size
            (pp_ctypes_type ~lift ~mod_name)
            typ
      | None -> Format.fprintf fmt "type_TODO_array")
  | TFun (rettyp, args, _, _) ->
      Format.fprintf fmt "@[<hov2>(%a @-> returning %a)@]"
        (pp_ctypes_types ~lift ~mod_name)
        args
        (pp_ctypes_type ~lift ~mod_name)
        rettyp
  | TNamed ({ tname; ttype; _ }, _) -> (
      let name =
        match mangle_name tname with "size_t" -> "int_as_size_t" | s -> s
      in
      match ttype with
      | TEnum ({ ename; _ }, _) ->
          let enum_module_name = enum_module_name ename in
          Format.fprintf fmt "@[<hov>(lift_typ %s.t)@]" enum_module_name
      | TComp ({ cname; _ }, _) when mod_name ->
          let module_name = mangle_struct_name cname in
            let is_defined = Strs.mem name !defined in
            if
              lift
              && not is_defined
              && module_name <> !current_struct
            then Format.fprintf fmt "@[<hov>(lift_typ@ %s)@]" name
            else Format.fprintf fmt "@[<hov>%s@]" name
      | _ ->
          if lift then Format.fprintf fmt "@[<hov>(lift_typ@ %s)@]" name
          else Format.fprintf fmt "@[<hov>%s@]" name)
  | TComp _ -> Format.fprintf fmt "type_TODO_comp"
  | TEnum _ -> Format.fprintf fmt "type_TODO_named"
  | TBuiltin_va_list _ -> Format.fprintf fmt "type_TODO_valist"

and pp_ctypes_types ~lift ~mod_name fmt args =
  match args with
  | None | Some [] -> Format.fprintf fmt "unit"
  | Some args ->
      Format.pp_print_list ~pp_sep:pp_ctypes_arrow
        (fun fmt (_, typ, _) -> pp_ctypes_type ~lift ~mod_name fmt typ)
        fmt args

let pp_suffix fmt = function
  | TComp ({ cstruct = true; _ }, _) -> Format.fprintf fmt "@ structure"
  | _ -> ()

let rec pp_ocaml_type ~mod_name fmt = function
  | TVoid _ -> Format.fprintf fmt "unit"
  | TInt (ikind, _) ->
      Format.fprintf fmt
        (match ikind with
        | IInt -> "int"
        | IShort -> "int"
        | ISChar -> "int"
        | IBool -> "bool"
        | IChar -> "char"
        | IUInt -> "int"
        | IUShort -> "int"
        | IUChar -> "int"
        | _ -> "int_TODO")
  | TFloat _ -> Format.fprintf fmt "float"
  | TPtr (typ, _) -> (
      match typ with
      | TInt (IChar, _) -> Format.fprintf fmt "string"
      | TFun _ ->
          Format.fprintf fmt "@[<hov>(%a)@]" (pp_ocaml_type ~mod_name) typ
      | _ -> Format.fprintf fmt "@[<hov>%a@ ptr@]" (pp_ocaml_type ~mod_name) typ
      )
  | TArray (typ, _, _) ->
      Format.fprintf fmt "@[<hov>%a carray@]" (pp_ocaml_type ~mod_name) typ
  | TFun (typ, args, _, _) ->
      Format.fprintf fmt "@[<hov>%a -> %a@]" (pp_ocaml_types ~mod_name) args
        (pp_ocaml_type ~mod_name) typ
  | TNamed ({ tname; ttype; _ }, _) -> (
      let name = match mangle_name tname with "size_t" -> "int" | s -> s in
      match ttype with
      | TEnum ({ ename; _ }, _) ->
          let enum_module_name = enum_module_name ename in
          Format.fprintf fmt "@[<hov>%s.t@]" enum_module_name
      | TComp ({ cname; _ }, _) when mod_name ->
          let module_name = mangle_struct_name cname in
          if Option.is_none (List.find_opt (( = ) module_name) abstract_structs)
          then
            if Strs.mem module_name !defined then
              Format.fprintf fmt "@[<hov>%s.t@]" module_name
            else Format.fprintf fmt "@[<hov>Base.%s.t@]" module_name
          else Format.fprintf fmt "@[<hov>%s structure@]" name
      | TComp _ -> Format.fprintf fmt "@[<hov>%s structure@]" name
      | TNamed _ ->
          Format.fprintf fmt "@[<hov>%a@]" (pp_ocaml_type ~mod_name) ttype
      | _ -> Format.fprintf fmt "@[<hov>%s@]" name)
  | TComp _ -> Format.fprintf fmt "type_TODO_comp"
  | TEnum _ -> Format.fprintf fmt "type_TODO_comp"
  | TBuiltin_va_list _ -> Format.fprintf fmt "type_TODO_valist"

and pp_ocaml_types ~mod_name fmt args =
  match args with
  | None | Some [] -> Format.fprintf fmt "unit"
  | Some args ->
      Format.pp_print_list ~pp_sep:pp_ocaml_arrow
        (fun fmt (_, typ, _) -> (pp_ocaml_type ~mod_name) fmt typ)
        fmt args

let pp_enum fmt { ename; eitems; _ } =
  let ename_no_ =
    if String.ends_with ~suffix:"_" ename then
      String.sub ename 0 (String.length ename - 1)
    else ename
  in
  let enum_module_name =
    if String.starts_with ~prefix:"ImGui" ename_no_ then
      String.sub ename_no_ 5 (String.length ename_no_ - 5)
    else if String.starts_with ~prefix:"Im" ename_no_ then
      String.sub ename_no_ 2 (String.length ename_no_ - 2)
    else ename_no_
  in
  let ename_regexp =
    if String.ends_with ~suffix:"Private" enum_module_name then
      let regexp = Str.regexp "Private" in
      let ename = Str.global_replace regexp "" ename in
      Str.regexp ename
    else Str.regexp ename
  in
  Format.fprintf fmt
    "@[<hov 2>@[<hov>module@ %s@ =@ struct@]@\n\
     @[<hov>type@ t@ =@]@\n\
     %a@\n\
     %a@\n\
     @[<hov 2>let@ t@ :@ t@ typ@ =@ @[<hov 2>enum@ %S@ ~typedef:true@ \
     [@[<hv>%a@]]@]\n\
    \     @]@]@\n\
     end@\n"
    enum_module_name
    (fun fmt ->
      List.iter (fun (name, _, _) ->
          let name = mangle_enum_variant ename_regexp name in
          Format.fprintf fmt "@[<hov>|@ %s@]@\n"
            (Str.global_replace ename_regexp "" name)))
    eitems
    (fun fmt ->
      List.iter (fun (name, _, _) ->
          let variant_name = mangle_enum_variant ename_regexp name in
          let val_name = camlCase_to_snake_case variant_name in
          let val_name =
            if val_name.[0] = '_' then
              String.sub val_name 1 (String.length val_name - 1)
            else val_name
          in
          let val_name =
            match val_name with "end" -> "end_" | _ -> val_name
          in
          Format.fprintf fmt
            "@[<hov 2>let@ %s@ =@ @[<hov 2>constant@ %S@ int64_t@]@]@\n"
            val_name name))
    eitems ename
    (Format.pp_print_list
       ~pp_sep:(fun fmt () -> Format.fprintf fmt ";@ ")
       (fun fmt (name, _, _) ->
         let variant_name = mangle_enum_variant ename_regexp name in
         let val_name = camlCase_to_snake_case variant_name in
         let val_name =
           if val_name.[0] = '_' then
             String.sub val_name 1 (String.length val_name - 1)
           else val_name
         in
         let val_name = match val_name with "end" -> "end_" | _ -> val_name in
         Format.fprintf fmt "@[<hov 2>(%s, %s)@]" variant_name val_name))
    eitems

let pp_enums fmt globals =
  Format.fprintf fmt
    "@[<hov 2>@[<hov>module@ Enums@ (S@ :@ Cstubs_structs.TYPE)@ =@ struct@]@\n\
     open S@\n\
     %a@]@\n\
     end@\n"
    (fun fmt ->
      List.iter @@ function
      | GType ({ tname; ttype = TEnum (enuminfo, _); _ }, _) ->
          if String.starts_with ~prefix:"Im" tname then
            pp_enum fmt { enuminfo with ename = tname }
      | _ -> ())
    globals

let rec _pp_sig fmt fields =
  Format.pp_print_list
    ~pp_sep:(fun fmt () -> Format.fprintf fmt "@\n")
    (fun fmt { fname; ftype; _ } ->
      let field_ml_name = mangle_field_name fname in
      match ftype with
      | TComp ({ cstruct = false; cfields; _ }, _) -> _pp_sig fmt cfields
      | _ ->
          Format.fprintf fmt "@[<hov 2>@[<hov>val@ %s:@ (%a,@ t)@ S.field@]@]"
            field_ml_name
            (pp_ocaml_type ~mod_name:true)
            ftype)
    fmt fields

let rec pp_fields fmt (fields, prefix_name, type_name) =
  List.iter
    (fun { fname; ftype; _ } ->
      let field_ml_name = mangle_field_name fname in
      match ftype with
      | TComp ({ cstruct = false; cfields; _ }, _) ->
          pp_fields fmt (cfields, prefix_name, type_name)
      | _ ->
          Format.fprintf fmt
            "@[<hov 2>@[<hov>let@ %s_%s@ =@]@ @[<hov 2>field@ %s@ %S@ %a@]@]@\n"
            prefix_name field_ml_name type_name fname
            (pp_ctypes_type ~lift:true ~mod_name:true)
            ftype)
    fields

let pp_struct fmt cname fields =
  let name = mangle_struct_name cname in
  let type_name = mangle_name cname in
  let prefix_name = String.sub type_name 0 (String.length type_name - 2) in
  current_struct := name;
  Format.fprintf fmt
    "@[<hov 2>@[<hov>let@ %s@ :@ %s structure typ@]@ =@ @[<hov 2>structure@ \
     %S@]@]@\n\
     %a@[<hov>let@ ()@ =@ seal %s@]@\n\
     @]@\n\
     @\n"
    type_name type_name cname pp_fields
    (fields, prefix_name, type_name)
    type_name;
  defined := Strs.add type_name !defined

let pp_base_modules fmt globals =
  Format.fprintf fmt "@[<hov 2>%a@]@\n"
    (Format.pp_print_list
       ~pp_sep:(fun fmt () -> Format.fprintf fmt "@,")
       (fun fmt global ->
         match global with
         | GCompTag ({ cstruct = true; cname; _ }, _) ->
             if
               String.starts_with ~prefix:"Im" cname
               || String.starts_with ~prefix:"STB" cname
               || String.starts_with ~prefix:"Stb" cname
             then
               let module_name = mangle_struct_name cname in
               let type_name = mangle_name cname in
               Format.fprintf fmt
                 "@[<hov 2>@[<hov>module %s@ =@ struct@]@\n\
                  @[<hov>type@ t@ =@ %s@ structure@]@\n\
                  @[<hov>let@ t@ :@ t@ typ@ =@ structure@ %S@]@]@\n\
                  end@\n"
                 module_name type_name cname
         | _ -> ()))
    globals

let pp_structs fmt globals =
  Format.fprintf fmt
    "@[<hov>open@ Cimgui_enums.Enums@ (Cimgui_enums_generated)@]@\n\
     @[<hov>module Base = \
     Cimgui_base_structs.Base(Cimgui_base_structs_generated)@]\n\
    \     @[<hov 2>@[<hov>module@ Structs@ (S@ :@ Cstubs_structs.TYPE)@ =@ \
     struct@]@\n\
     @[<hov>open@ S@]@\n\
     %a@]@\n\
     end@\n"
    (fun fmt ->
      List.iter (fun global ->
          match global with
          | GCompTag ({ cstruct = true; cname; cfields; _ }, _) ->
              if
                String.starts_with ~prefix:"Im" cname
                || String.starts_with ~prefix:"STB" cname
                || String.starts_with ~prefix:"Stb" cname
              then pp_struct fmt cname cfields
          | _ -> ()))
    globals

let pp_types fmt globals =
  List.iter
    (fun global ->
      match global with
      | GType ({ tname; ttype; _ }, _) -> (
          if
            String.starts_with ~prefix:"Im" tname
            || String.starts_with ~prefix:"STB" tname
            || String.starts_with ~prefix:"Stb" tname
          then
            match ttype with
            | TComp ({ cstruct = true; cname; _ }, _) ->
                let name = mangle_name tname in
                Format.fprintf fmt
                  "@[<hov>type@ %s@]@\n\
                   @[<hov 2>let@ %s@ :@ @[<hv>%s@ structure@ typ@]@ =@ @[<hov \
                   2>typedef@ @[<hov 2>(structure@ %S)@]@ %S@]@]@\n\
                   @\n"
                  name name name cname tname
            | TInt (ikind, _) -> (
                match ikind with
                | IInt ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ int@ \
                       %S@]@]@\n\
                       @\n"
                      name name name tname
                | IUShort ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_ushort@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | IUInt ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_uint@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | IShort ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ short@ \
                       %S@]@]@\n\
                       @\n"
                      name name name tname
                | ISChar ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ schar@ \
                       %S@]@]@\n\
                       @\n"
                      name name name tname
                | IUChar ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_uchar@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | ILongLong ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_sllong@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | IULongLong ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_ullong@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | _ ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_TODO@ %S@]@]@\n\
                       @\n"
                      name name name tname)
            | TPtr (TFun (retyp, args, _variadic, _), _) ->
                let name = mangle_name tname in
                Format.fprintf fmt
                  "@[<hov 2>type@ %s@ =@ @[<hov>%a -> %a@]@]@\n\
                   @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hov 2>typedef@ @[<hov \
                   2>(Foreign.funptr@ (%a @-> returning %a))@]@ %S@]@]@\n\
                   @\n"
                  name
                  (pp_ocaml_types ~mod_name:false)
                  args
                  (pp_ocaml_type ~mod_name:false)
                  retyp name name
                  (pp_ctypes_types ~lift:false ~mod_name:false)
                  args
                  (pp_ctypes_type ~lift:false ~mod_name:false)
                  retyp tname
            | TPtr _ ->
                let name = mangle_name tname in
                Format.fprintf fmt
                  "@[<hov 2>type@ %s@ =@ %a@]@\n\
                   @[<hov 2>let@ %s@ :@ %s@ typ@ = @[<hov 2>typedef@ %a@ %S@]@]@\n\
                   @\n"
                  name
                  (pp_ocaml_type ~mod_name:false)
                  ttype name name
                  (pp_ctypes_type ~lift:false ~mod_name:false)
                  ttype tname
            | TNamed ({ tname = dest_type; ttype; _ }, _) ->
                let name = mangle_name tname in
                let dest_name = mangle_name dest_type in
                Format.fprintf fmt
                  "@[<hov 2>type@ %s@ =@ %s@]@\n\
                   @[<hov 2>let@ %s@ :@ %s%a@ typ@ =@ @[<hov>typedef@ %s@ \
                   %S@]@]@\n\
                   @\n"
                  name dest_name name name pp_suffix ttype dest_name tname
            | _ -> ())
      | _ -> ())
    globals

let pp_base fmt globals =
  Format.fprintf fmt
    "@[<hov>open@ Ctypes@]@\n\
     @[<hov>open@ Cimgui_types@]@\n\
     @[<hov 2>module@ Base@ (S@ :@ Cstubs_structs.TYPE)@ =@ struct@\n\
     @[<hov>open@ S@]@\n\
     %a@]@\n\
     end"
    pp_base_modules globals

let () =
  let file = Frontc.parse filename () in
  let types_out_c = open_out types_output in
  let types_fmt = Format.formatter_of_out_channel types_out_c in
  let enums_out_c = open_out enums_output in
  let enums_fmt = Format.formatter_of_out_channel enums_out_c in
  let base_structs_out_c = open_out base_structs_output in
  let base_structs_fmt = Format.formatter_of_out_channel base_structs_out_c in
  let structs_out_c = open_out structs_output in
  let structs_fmt = Format.formatter_of_out_channel structs_out_c in
  let globals = file.globals in
  Format.set_geometry ~max_indent:68 ~margin:80;
  pp_header types_fmt;
  Format.fprintf types_fmt "@[<hov>open@ Ctypes@]@\n";
  pp_prolog types_fmt;
  pp_header enums_fmt;
  pp_header structs_fmt;
  Format.fprintf structs_fmt "@[<hov>open@ Ctypes@]@\n";
  Format.fprintf structs_fmt "@[<hov>open@ Cimgui_types@]@\n";
  pp_types types_fmt globals;
  pp_enums enums_fmt globals;
  pp_base base_structs_fmt globals;
  pp_structs structs_fmt globals;
  Format.pp_print_flush types_fmt ();
  Format.pp_print_flush enums_fmt ();
  Format.pp_print_flush base_structs_fmt ();
  Format.pp_print_flush structs_fmt ();
  close_out types_out_c;
  close_out enums_out_c;
  close_out base_structs_out_c;
  close_out structs_out_c
