open GoblintCil
module StrMap = Map.Make (String)

let c_file = Sys.argv.(1)
let generator_stage = Sys.argv.(2)

let replacements =
  List.map
    (fun (reg, rep) -> (Str.regexp reg, rep))
    [
      ("IO", "Io");
      ("ImGui", "Im");
      ("ID", "Id");
      ("COUNT", "count");
      ("BEGIN", "Begin");
      ("END", "End");
      ("OSX", "Osx");
      ("SIZE", "Size");
      ("OFFSET", "Offset");
      ("SRGB", "Srgb");
      ("HDR", "Hdr");
      ("TTY", "Tty");
      ("FILE", "File");
      ("STB", "Stb");
      ("GET", "Get");
      ("FLT", "Flt");
      ("MAX", "Max");
      ("MIN", "Min");
      ("RGBt", "RgbT");
      ("RGB", "Rgb");
      ("HSVt", "HsvT");
      ("HSV", "Hsv");
      ("UTF", "Utf");
      ("UV", "Uv");
      ("TTF", "Ttf");
      ("TL", "Tl");
      ("TR", "Tr");
      ("BR", "Br");
      ("BL", "Bl");
      ("DC", "Dc");
    ]

let abstract_structs = [ "DockRequest"; "DockNodeSettings" ]

let has_bit_fields =
  [
    "ImGuiDockNode";
    "ImGuiStackLevelInfo";
    "ImGuiContext";
    "ImGuiWindow";
    "ImGuiTableColumn";
    "ImGuiTable";
    "ImGuiTableColumnSettings";
    "ImGuiNextItemData";
    "ImGuiTableColumnSortSpecs";
    "ImFontGlyph";
  ]

let stages =
  [
    ("ImVec2", 0);
    ("ImVec4", 0);
    ("ImVec2ih", 0);
    ("ImVector_ImGuiWindowPtr", 1);
    ("ImGuiWindowClass", 1);
    ("ImGuiIO", 1);
    ("ImGuiPlatformIO", 1);
    ("ImGuiStyle", 1);
    ("ImDrawListSharedData", 1);
    ("ImVector_ImGuiInputEvent", 1);
    ("ImVector_ImGuiWindowStackData", 1);
    ("ImGuiStorage", 1);
    ("ImGuiKeyOwnerData", 1);
    ("ImGuiKeyRoutingTable", 1);
    ("ImGuiLastItemData", 1);
    ("ImGuiNextWindowData", 1);
    ("ImVector_ImGuiColorMod", 1);
    ("ImVector_ImGuiStyleMod", 1);
    ("ImVector_ImFontPtr", 1);
    ("ImVector_ImGuiFocusScopeData", 1);
    ("ImVector_ImGuiItemFlags", 1);
    ("ImVector_ImGuiGroupData", 1);
    ("ImVector_ImGuiPopupData", 1);
    ("ImVector_ImGuiNavTreeNodeData", 1);
    ("ImVector_ImGuiViewportPPtr", 1);
    ("ImGuiPlatformMonitor", 1);
    ("ImRect", 1);
    ("ImGuiNavItemData", 1);
    ("ImGuiPayload", 1);
    ("ImVector_unsigned_char", 1);
    ("ImVector_ImGuiListClipperData", 1);
    ("ImVector_ImGuiTableTempData", 1);
    ("ImPool_ImGuiTable", 1);
    ("ImVector_float", 1);
    ("ImVector_ImDrawChannel", 1);
    ("ImPool_ImGuiTabBar", 1);
    ("ImVector_ImGuiPtrOrIndex", 1);
    ("ImVector_ImGuiShrinkWidthItem", 1);
    ("ImGuiInputTextState", 1);
    ("ImGuiInputTextDeactivatedState", 1);
    ("ImFont", 1);
    ("ImGuiComboPreviewData", 1);
    ("ImVector_char", 1);
    ("ImVector_ImGuiID", 1);
    ("ImGuiTypingSelectState", 1);
    ("ImGuiPlatformImeData", 1);
    ("ImGuiDockContext", 1);
    ("ImGuiTextBuffer", 1);
    ("ImVector_ImGuiSettingsHandler", 1);
    ("ImChunkStream_ImGuiWindowSettings", 1);
    ("ImChunkStream_ImGuiTableSettings", 1);
    ("ImVector_ImGuiContextHook", 1);
    ("ImGuiTextIndex", 1);
    ("ImGuiMetricsConfig", 1);
    ("ImGuiIDStackTool", 1);
    ("ImGuiDebugAllocInfo", 1);
    ("ImGuiWindowTempData", 1);
    ("ImVector_ImGuiOldColumns", 1);
    ("ImDrawList", 1);
    ("ImGuiWindowDockStyle", 1);
    ("ImSpan_ImGuiTableColumn", 1);
    ("ImSpan_ImGuiTableColumnIdx", 1);
    ("ImSpan_ImGuiTableCellData", 1);
    ("ImGuiTableInstanceData", 1);
    ("ImVector_ImGuiTableInstanceData", 1);
    ("ImGuiTableColumnSortSpecs", 1);
    ("ImVector_ImGuiTableColumnSortSpecs", 1);
    ("ImGuiTableSortSpecs", 1);
    ("ImGuiNextItemData", 1);
    ("ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN", 1);
  ]

let redefine_after =
  [
    ( "ImBitArrayForNamedKeys",
      ("ImBitArray_ImGuiKey_NamedKey_COUNT__lessImGuiKey_NamedKey_BEGIN", 1) );
  ]

let args_types =
  [
    (("igSetNextWindowSizeConstraints", "custom_callback"), "size_callback_t");
    (("igInputText", "callback"), "input_text_callback_t");
    (("igInputTextMultiline", "callback"), "input_text_callback_t");
    (("igInputTextWithHint", "callback"), "input_text_callback_t");
    (("igSetAllocatorFunctions", "alloc_func"), "mem_alloc_func_t");
    (("igSetAllocatorFunctions", "free_func"), "mem_free_func_t");
    (("ImDrawList_AddCallback", "callback"), "draw_callback_t");
    (("igInputTextEx", "callback"), "input_text_callback_t");
    (("igErrorCheckEndFrameRecover", "log_callback"), "error_log_callback_t");
    (("igErrorCheckEndWindowRecover", "log_callback"), "error_log_callback_t");
  ]

let defined = ref StrMap.empty
let current_struct = ref ""
let current_func = ref ""
let defined_funcs = Hashtbl.create 1024
let stage = ref (-1)
let max_stage = 1

let () =
  Hashtbl.add defined_funcs
    (TFun (charConstPtrType, Some [ ("user_data", voidPtrType, []) ], false, []))
    "getter_t"

let _pp_type fmt typ =
  let doc = Cil.printType Cil.defaultCilPrinter () typ in
  Format.fprintf fmt "%s" (Pretty.sprint ~width:80 doc)

let pp_header fmt =
  let time = Unix.gmtime (Unix.time ()) in
  Format.fprintf fmt
    "(* This file was generated by imguiml_generator.exe on %02d/%02d/%04d at \
     %02d:%02d:%02d *)\n"
    time.tm_mday time.tm_mon (time.tm_year + 1900) time.tm_hour time.tm_min
    time.tm_sec

let pp_prolog fmt =
  Format.fprintf fmt
    {ocaml|
let int_as_uchar =
  view ~read:Unsigned.UChar.to_int
       ~write:Unsigned.UChar.of_int
       uchar

let int_as_ushort =
  view ~read:Unsigned.UShort.to_int
       ~write:Unsigned.UShort.of_int
       ushort

let int_as_uint =
  view ~read:Unsigned.UInt.to_int
       ~write:Unsigned.UInt.of_int
       uint

let int_as_ulong =
  view ~read:Unsigned.ULong.to_int
       ~write:Unsigned.ULong.of_int
       ulong

let int_as_ullong =
  view ~read:Unsigned.ULLong.to_int
       ~write:Unsigned.ULLong.of_int
       ullong

let int_as_sint =
  view ~read:Signed.SInt.to_int
       ~write:Signed.SInt.of_int
       sint

let int_as_sllong =
  view ~read:Signed.LLong.to_int
       ~write:Signed.LLong.of_int
       llong

let int_as_size_t =
  view ~read:Unsigned.Size_t.to_int
       ~write:Unsigned.Size_t.of_int
       size_t

type file_t
let file_t : file_t structure typ = typedef (structure "FILE") "FILE"

type va_list_t = unit ptr
let va_list_t : va_list_t typ = ptr void

type getter_t = unit ptr -> int -> string
let getter_t : getter_t typ =
  Foreign.funptr (ptr void @-> int @-> returning string)

type values_getter_t = unit ptr -> int -> float
let values_getter_t : values_getter_t typ =
  Foreign.funptr (ptr void @-> int @-> returning float)

type compare_func_t = unit ptr -> unit ptr -> int
let compare_func_t : compare_func_t typ =
  Foreign.funptr (ptr void @-> ptr void @-> returning int)

type get_item_name_func_t = unit ptr -> int -> string
let get_item_name_func_t : get_item_name_func_t typ =
  Foreign.funptr (ptr void @-> int @-> returning string)

let (>>) a b = a lsr b

|ocaml}

let camlCase_to_snake_case ?(remove_ = false) str =
  let str =
    List.fold_left
      (fun str (reg, rep) -> Str.global_replace reg rep str)
      str replacements
  in
  let buffer = Buffer.create @@ (2 * String.length str) in
  let _ =
    String.fold_left
      (fun acc c ->
        match c with
        | 'A' .. 'Z' ->
            if not acc then Buffer.add_char buffer '_';
            Buffer.add_char buffer (Char.lowercase_ascii c);
            false
        | '_' ->
            Buffer.add_char buffer '_';
            true
        | _ ->
            Buffer.add_char buffer c;
            false)
      false str
  in
  let str = Buffer.contents buffer in
  if remove_ then
    if String.starts_with ~prefix:"_" str then
      String.sub str 1 (String.length str - 1)
    else str
  else str

let mangle_name name =
  match name with
  | "size_t" -> "size_t"
  | "va_list" -> "va_list_t"
  | _ ->
      let no_im =
        if String.starts_with ~prefix:"ImGui" name then
          String.sub name 5 (String.length name - 5)
        else if String.starts_with ~prefix:"Im" name then
          String.sub name 2 (String.length name - 2)
        else name
      in
      let no_im =
        List.fold_left
          (fun no_im (base, replacement) ->
            Str.global_replace base replacement no_im)
          no_im replacements
      in
      let str = camlCase_to_snake_case no_im in
      String.sub str 1 (String.length str - 1) ^ "_t"

let mangle_field_name name =
  let name =
    List.fold_left
      (fun name (reg, rep) -> Str.global_replace reg rep name)
      name replacements
  in
  let str = camlCase_to_snake_case name in
  let str =
    if str.[0] = '_' then String.sub str 1 (String.length str - 1) else str
  in
  match str with "type" -> "type_" | _ -> str

let mangle_struct_name name =
  let name =
    List.fold_left
      (fun name (reg, rep) -> Str.global_replace reg rep name)
      name replacements
  in
  if String.starts_with ~prefix:"Im" name then
    String.sub name 2 (String.length name - 2)
  else name

let mangle_enum_variant regexp name =
  let name = Str.global_replace regexp "" name in
  let name =
    if String.starts_with ~prefix:"_" name then
      String.sub name 1 (String.length name - 1)
    else name
  in
  match name.[0] with '0' .. '9' -> "K" ^ name | _ -> name

let pp_ocaml_arrow fmt () = Format.fprintf fmt "@ ->@ "
let pp_ctypes_arrow fmt () = Format.fprintf fmt "@ @->@ "

let pp_exp fmt exp =
  let doc = Cil.printExp Cil.defaultCilPrinter () exp in
  Format.fprintf fmt "%s" (Pretty.sprint ~width:80 doc)

let enum_module_name ename =
  let ename =
    let prefix_regexp = Str.regexp "__anonenum_" in
    let suffix_regexp = Str.regexp "[0-9]+$" in
    Str.global_replace prefix_regexp "" ename
    |> Str.global_replace suffix_regexp ""
  in
  let ename_no_ =
    if String.ends_with ~suffix:"_" ename then
      String.sub ename 0 (String.length ename - 1)
    else ename
  in
  if String.starts_with ~prefix:"ImGui" ename_no_ then
    String.sub ename_no_ 5 (String.length ename_no_ - 5)
  else if String.starts_with ~prefix:"Im" ename_no_ then
    String.sub ename_no_ 2 (String.length ename_no_ - 2)
  else ename_no_

let rec pp_ctypes_type ~in_bindings ~lift ~mod_name fmt = function
  | TVoid _ -> Format.fprintf fmt "void"
  | TInt (ikind, _) ->
      Format.fprintf fmt
        (match ikind with
        | IInt -> "int"
        | IShort -> "short"
        | ISChar -> "schar"
        | IBool -> "bool"
        | IChar -> "char"
        | IUInt ->
            if lift then "@[<hov>(lift_typ@ int_as_uint)@]" else "int_as_uint"
        | IUShort ->
            if lift then "@[<hov>(lift_typ@ int_as_ushort)@]"
            else "int_as_ushort"
        | IUChar ->
            if lift then "@[<hov>(lift_typ@ int_as_uchar)@]" else "int_as_uchar"
        | _ -> "int_TODO")
  | TFloat _ -> Format.fprintf fmt "float"
  | TPtr (typ, _) -> (
      match typ with
      | TInt (IChar, _) -> Format.fprintf fmt "string"
      | TFun _ as tfun ->
          if lift && not in_bindings then
            Format.fprintf fmt
              "@[<hov 2>(lift_typ@ @[<hov 2>(Foreign.funptr@ %a)@])@]"
              (pp_ctypes_type ~in_bindings ~lift ~mod_name)
              typ
          else if in_bindings then
            if Hashtbl.mem defined_funcs tfun then
              let type_name = mangle_name (Hashtbl.find defined_funcs tfun) in
              Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" type_name
            else
              Format.fprintf fmt "@[<hov 2>(Foreign.funptr@ %a)@]"
                (pp_ctypes_type ~in_bindings ~lift:false ~mod_name)
                typ
          else
            Format.fprintf fmt "@[<hov 2>(Foreign.funptr@ %a)@]"
              (pp_ctypes_type ~in_bindings ~lift ~mod_name)
              typ
      | _ ->
          Format.fprintf fmt "@[<hov 2>(ptr@ %a)@]"
            (pp_ctypes_type ~in_bindings ~lift ~mod_name)
            typ)
  | TArray (typ, size, _) -> (
      match size with
      | Some size ->
          Format.fprintf fmt "@[<hov 2>(array@ (%a)@ %a)@]" pp_exp size
            (pp_ctypes_type ~in_bindings ~lift ~mod_name)
            typ
      | None -> Format.fprintf fmt "type_TODO_array")
  | TFun (rettyp, args, _, _) ->
      Format.fprintf fmt "@[<hov 2>(%a@ @[<hov 2>@->@ returning %a@])@]"
        (pp_ctypes_types ~in_bindings ~lift ~mod_name)
        args
        (pp_ctypes_type ~in_bindings ~lift ~mod_name)
        rettyp
  | TNamed ({ tname; ttype; _ }, _) -> (
      let name =
        match mangle_name tname with "size_t" -> "int_as_size_t" | s -> s
      in
      match ttype with
      | TEnum ({ ename; _ }, _) ->
          let enum_module_name = enum_module_name ename in
          Format.fprintf fmt "@[<hov 2>(lift_typ %s.t)@]" enum_module_name
      | TComp ({ cname; _ }, _) when mod_name ->
          let module_name = mangle_struct_name cname in
          let is_defined_before =
            match List.assoc_opt cname stages with
            | Some defined_stage when defined_stage < !stage ->
                true
            | _ when in_bindings -> true
            | _ -> false
          in
          let is_redefined =
            match List.assoc_opt cname redefine_after with
            | Some (_, x) when !stage > x -> true
            | Some _ -> true
            | _ -> false
          in
          if is_defined_before || is_redefined then
            if lift && not (List.mem module_name abstract_structs) then
              Format.fprintf fmt "@[<hov 2>(lift_typ@ %s.t)@]" module_name
            else if lift then
              Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" (mangle_name cname)
            else Format.fprintf fmt "%s" (mangle_name cname)
          else if lift then
            Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" (mangle_name cname)
          else Format.fprintf fmt "%s" (mangle_name cname)
      | TFun (_, _, _, _) when in_bindings ->
          Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" tname
      | TNamed ({ tname = base_type; _ }, _) -> (
          match List.assoc_opt tname redefine_after with
          | Some (_, x) when x < !stage ->
              let module_name = mangle_struct_name base_type in
              Format.fprintf fmt "@[<hov 2>(lift_typ@ %s.t)@]" module_name
          | _ ->
              if lift then Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" name
              else Format.fprintf fmt "@[<hov>%s@]" name)
      | _ ->
          if lift then Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" name
          else Format.fprintf fmt "@[<hov>%s@]" name)
  | TComp ({ cname; _ }, _) ->
      let module_name = mangle_struct_name cname in
      let is_defined_before =
        match List.assoc_opt cname stages with
        | Some defined_stage when defined_stage < !stage -> true
        | _ when in_bindings -> true
        | _ -> false
      in
      let is_redefined =
        match List.assoc_opt cname redefine_after with
        | Some (_, x) when !stage > x -> true
        | Some _ -> true
        | _ -> false
      in
      if is_defined_before || is_redefined then
        if lift && not (List.mem module_name abstract_structs) then
          Format.fprintf fmt "@[<hov 2>(lift_typ@ %s.t)@]" module_name
        else if lift then
          Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" (mangle_name cname)
        else Format.fprintf fmt "%s" (mangle_name cname)
      else if lift then
        Format.fprintf fmt "@[<hov 2>(lift_typ@ %s)@]" (mangle_name cname)
      else Format.fprintf fmt "%s" (mangle_name cname)
  | TEnum _ -> Format.fprintf fmt "type_TODO_enum"
  | TBuiltin_va_list _ -> Format.fprintf fmt "type_TODO_valist"

and pp_ctypes_types ~in_bindings ~lift ~mod_name fmt args =
  match args with
  | None | Some [] -> Format.fprintf fmt "void"
  | Some args ->
      Format.pp_print_list ~pp_sep:pp_ctypes_arrow
        (fun fmt (name, typ, _) ->
          match name with
          | "getter" -> Format.fprintf fmt "getter_t"
          | "values_getter" -> Format.fprintf fmt "values_getter_t"
          | "compare_func" -> Format.fprintf fmt "compare_func_t"
          | "get_item_name_func" -> Format.fprintf fmt "get_item_name_func_t"
          | _ ->
              if List.mem_assoc (!current_func, name) args_types then
                Format.fprintf fmt "%s"
                  (List.assoc (!current_func, name) args_types)
              else pp_ctypes_type ~in_bindings ~lift ~mod_name fmt typ)
        fmt args

let pp_suffix fmt = function
  | TComp ({ cstruct = true; _ }, _) -> Format.fprintf fmt "@ structure"
  | _ -> ()

let rec pp_ocaml_type ~mod_name fmt = function
  | TVoid _ -> Format.fprintf fmt "unit"
  | TInt (ikind, _) ->
      Format.fprintf fmt
        (match ikind with
        | IInt -> "int"
        | IShort -> "int"
        | ISChar -> "int"
        | IBool -> "bool"
        | IChar -> "char"
        | IUInt -> "int"
        | IUShort -> "int"
        | IUChar -> "int"
        | _ -> "int_TODO")
  | TFloat _ -> Format.fprintf fmt "float"
  | TPtr (typ, _) -> (
      match typ with
      | TInt (IChar, _) -> Format.fprintf fmt "string"
      | TFun _ ->
          Format.fprintf fmt "@[<hov>(%a)@]" (pp_ocaml_type ~mod_name) typ
      | _ -> Format.fprintf fmt "@[<hov>%a@ ptr@]" (pp_ocaml_type ~mod_name) typ
      )
  | TArray (typ, _, _) ->
      Format.fprintf fmt "@[<hov>%a carray@]" (pp_ocaml_type ~mod_name) typ
  | TFun (typ, args, _, _) ->
      Format.fprintf fmt "@[<hov>%a -> %a@]" (pp_ocaml_types ~mod_name) args
        (pp_ocaml_type ~mod_name) typ
  | TNamed ({ tname; ttype; _ }, _) -> (
      let name = match mangle_name tname with "size_t" -> "int" | s -> s in
      match ttype with
      | TEnum ({ ename; _ }, _) ->
          let enum_module_name = enum_module_name ename in
          Format.fprintf fmt "@[<hov>%s.t@]" enum_module_name
      | TComp ({ cname; _ }, _) when mod_name ->
          let module_name = mangle_struct_name cname in
          if Option.is_none (List.find_opt (( = ) module_name) abstract_structs)
          then
            if StrMap.mem module_name !defined then
              Format.fprintf fmt "@[<hov>%s.t@]" module_name
            else Format.fprintf fmt "@[<hov>Base.%s.t@]" module_name
          else Format.fprintf fmt "@[<hov>%s structure@]" name
      | TComp _ -> Format.fprintf fmt "@[<hov>%s structure@]" name
      | TNamed _ ->
          Format.fprintf fmt "@[<hov>%a@]" (pp_ocaml_type ~mod_name) ttype
      | _ -> Format.fprintf fmt "@[<hov>%s@]" name)
  | TComp _ -> Format.fprintf fmt "type_TODO_comp"
  | TEnum _ -> Format.fprintf fmt "type_TODO_comp"
  | TBuiltin_va_list _ -> Format.fprintf fmt "type_TODO_valist"

and pp_ocaml_types ~mod_name fmt args =
  match args with
  | None | Some [] -> Format.fprintf fmt "unit"
  | Some args ->
      Format.pp_print_list ~pp_sep:pp_ocaml_arrow
        (fun fmt (_, typ, _) -> (pp_ocaml_type ~mod_name) fmt typ)
        fmt args

let pp_enum fmt { ename; eitems; _ } =
  let ename_no_ =
    if String.ends_with ~suffix:"_" ename then
      String.sub ename 0 (String.length ename - 1)
    else ename
  in
  let enum_module_name =
    if String.starts_with ~prefix:"ImGui" ename_no_ then
      String.sub ename_no_ 5 (String.length ename_no_ - 5)
    else if String.starts_with ~prefix:"Im" ename_no_ then
      String.sub ename_no_ 2 (String.length ename_no_ - 2)
    else ename_no_
  in
  let ename_regexp =
    if String.ends_with ~suffix:"Private" enum_module_name then
      let regexp = Str.regexp "Private" in
      let ename = Str.global_replace regexp "" ename in
      Str.regexp ename
    else Str.regexp ename
  in
  Format.fprintf fmt
    "@[<hov 2>@[<hov>module@ %s@ =@ struct@]@\n\
     @[<hov>type@ t@ =@]@\n\
     %a@\n\
     %a@\n\
     @[<hov 2>let@ t@ :@ t@ typ@ =@ @[<hov 2>enum@ %S@ ~typedef:true@ \
     [@[<hv>%a@]]@]\n\
    \     @]@]@\n\
     end@\n"
    enum_module_name
    (fun fmt ->
      List.iter (fun (name, _, _) ->
          let name = mangle_enum_variant ename_regexp name in
          Format.fprintf fmt "@[<hov>|@ %s@]@\n"
            (Str.global_replace ename_regexp "" name)))
    eitems
    (fun fmt ->
      List.iter (fun (name, _, _) ->
          let variant_name = mangle_enum_variant ename_regexp name in
          let val_name = camlCase_to_snake_case variant_name in
          let val_name =
            if val_name.[0] = '_' then
              String.sub val_name 1 (String.length val_name - 1)
            else val_name
          in
          let val_name =
            match val_name with "end" -> "end_" | _ -> val_name
          in
          Format.fprintf fmt
            "@[<hov 2>let@ %s@ =@ @[<hov 2>constant@ %S@ int64_t@]@]@\n"
            val_name name))
    eitems ename
    (Format.pp_print_list
       ~pp_sep:(fun fmt () -> Format.fprintf fmt ";@ ")
       (fun fmt (name, _, _) ->
         let variant_name = mangle_enum_variant ename_regexp name in
         let val_name = camlCase_to_snake_case variant_name in
         let val_name =
           if val_name.[0] = '_' then
             String.sub val_name 1 (String.length val_name - 1)
           else val_name
         in
         let val_name = match val_name with "end" -> "end_" | _ -> val_name in
         Format.fprintf fmt "@[<hov 2>(%s, %s)@]" variant_name val_name))
    eitems

let pp_enums fmt globals =
  Format.fprintf fmt
    "@[<hov 2>@[<hov>module@ Enums@ (S@ :@ Ctypes.TYPE)@ =@ struct@]@\n\
     open S@\n\
     %a@]@\n\
     end@\n"
    (fun fmt ->
      List.iter @@ function
      | GType ({ tname; ttype = TEnum (enuminfo, _); _ }, _) ->
          if String.starts_with ~prefix:"Im" tname then
            pp_enum fmt { enuminfo with ename = tname }
      | _ -> ())
    globals

let rec _pp_sig fmt fields =
  Format.pp_print_list
    ~pp_sep:(fun fmt () -> Format.fprintf fmt "@\n")
    (fun fmt { fname; ftype; _ } ->
      let field_ml_name = mangle_field_name fname in
      match ftype with
      | TComp ({ cstruct = false; cfields; _ }, _) -> _pp_sig fmt cfields
      | _ ->
          Format.fprintf fmt "@[<hov 2>@[<hov>val@ %s:@ (%a,@ t)@ S.field@]@]"
            field_ml_name
            (pp_ocaml_type ~mod_name:true)
            ftype)
    fmt fields

let rec pp_fields fmt fields =
  List.iter
    (fun { fname; ftype; _ } ->
      let field_ml_name = mangle_field_name fname in
      match ftype with
      | TComp ({ cstruct = false; cfields; _ }, _) -> pp_fields fmt cfields
      | _ ->
          Format.fprintf fmt
            "@[<hov 2>@[<hov>let@ %s@ =@]@ @[<hov 2>field@ t@ %S@ %a@]@]@\n"
            field_ml_name fname
            (pp_ctypes_type ~in_bindings:false ~lift:true ~mod_name:true)
            ftype)
    fields

let pp_struct fmt cname fields =
  let module_name = mangle_struct_name cname in
  let type_name = mangle_name cname in
  current_struct := module_name;
  Format.fprintf fmt
    "@[<hov 2>@[<hov>module@ %s@ =@ struct@]@\n\
     @[<hov>type@ t@ =@ %s@ structure@]@\n\
     @[<hov>let@ t@ :@ t@ typ@ =@ structure@ %S@]@\n\
     %a@[<hov>let@ ()@ =@ seal@ t@]@]@\n\
     end@\n\
     @\n"
    module_name type_name cname pp_fields fields;
  defined := StrMap.add cname !stage !defined

let pp_base_modules fmt globals =
  Format.fprintf fmt "@[<hov 2>%a@]@\n"
    (Format.pp_print_list
       ~pp_sep:(fun fmt () -> Format.fprintf fmt "@,")
       (fun fmt global ->
         match global with
         | GCompTag ({ cstruct = true; cname; cfields; _ }, _) -> (
             if
               String.starts_with ~prefix:"Im" cname
               || String.starts_with ~prefix:"STB" cname
               || String.starts_with ~prefix:"Stb" cname
             then
               match List.assoc_opt cname stages with
               | Some 0 ->
                   let module_name = mangle_struct_name cname in
                   let type_name = mangle_name cname in
                   Format.fprintf fmt
                     "@[<hov 2>@[<hov>module %s@ =@ struct@]@\n\
                      @[<hov>type@ t@ =@ %s@ structure@]@\n\
                      @[<hov>let@ t@ :@ t@ typ@ =@ structure@ %S@]@\n\
                      %a@]@\n\
                      end@\n"
                     module_name type_name cname
                     (fun fmt fields ->
                       Format.fprintf fmt "%a@[<hov>let@ ()@ =@ seal@ t@]"
                         pp_fields fields)
                     cfields;
                   defined := StrMap.add cname !stage !defined
               | _ -> ())
         | _ -> ()))
    globals

let pp_structs fmt globals =
  Format.fprintf fmt
    "%a@[<hov 2>@[<hov>module@ Structs@ (S@ :@ Ctypes.TYPE)@ =@ struct@]@\n\
     @[<hov>open@ S@]@\n\
     %a@]@\n\
     end@\n"
    (fun fmt ->
      List.iter (fun global ->
          match global with
          | GCompTag ({ cstruct = true; cname; cfields; _ }, _)
            when List.mem cname has_bit_fields -> (
              match List.assoc_opt cname stages with
              | Some x when x = !stage -> pp_struct fmt cname cfields
              | Some _ -> ()
              | None ->
                  if !stage > max_stage then
                    if
                      String.starts_with ~prefix:"Im" cname
                      || String.starts_with ~prefix:"STB" cname
                      || String.starts_with ~prefix:"Stb" cname
                    then pp_struct fmt cname cfields)
          | _ -> ()))
    globals
    (fun fmt ->
      List.iter
        (fun (redefined, (typ, after)) ->
          if !stage = after + 1 then
            let name = mangle_struct_name redefined in
            let module_name = mangle_struct_name typ in
            Format.fprintf fmt
              "@[<hov 2>@[<hov 2>module@ %s@ =@ struct@]@\n\
               @[<hov 2>type@ t@ = %s.t@]@\n\
               @[<hov 2>let@ t@ :@ t@ typ@ =@ lift_typ@ %s.t@]@]@\n\
               end@\n"
              name module_name module_name)
        redefine_after;
      List.iter (fun global ->
          match global with
          | GCompTag ({ cstruct = true; cname; cfields; _ }, _)
            when not @@ List.mem cname has_bit_fields -> (
              match List.assoc_opt cname stages with
              | Some x when x = !stage -> pp_struct fmt cname cfields
              | Some _ -> ()
              | None ->
                  if !stage > max_stage then
                    if
                      String.starts_with ~prefix:"Im" cname
                      || String.starts_with ~prefix:"STB" cname
                      || String.starts_with ~prefix:"Stb" cname
                    then pp_struct fmt cname cfields)
          | _ -> ()))
    globals

let pp_types fmt globals =
  List.iter
    (fun global ->
      match global with
      | GType ({ tname; ttype; _ }, _) -> (
          if
            String.starts_with ~prefix:"Im" tname
            || String.starts_with ~prefix:"STB" tname
            || String.starts_with ~prefix:"Stb" tname
          then
            match ttype with
            | TComp ({ cstruct = true; cname; _ }, _) ->
                let name = mangle_name tname in
                Format.fprintf fmt
                  "@[<hov>type@ %s@]@\n\
                   @[<hov 2>let@ %s@ :@ @[<hv>%s@ structure@ typ@]@ =@ @[<hov \
                   2>typedef@ @[<hov 2>(structure@ %S)@]@ %S@]@]@\n\
                   @\n"
                  name name name cname tname
            | TInt (ikind, _) -> (
                match ikind with
                | IInt ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ int@ \
                       %S@]@]@\n\
                       @\n"
                      name name name tname
                | IUShort ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_ushort@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | IUInt ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_uint@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | IShort ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ short@ \
                       %S@]@]@\n\
                       @\n"
                      name name name tname
                | ISChar ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ schar@ \
                       %S@]@]@\n\
                       @\n"
                      name name name tname
                | IUChar ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_uchar@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | ILongLong ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_sllong@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | IULongLong ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_as_ullong@ %S@]@]@\n\
                       @\n"
                      name name name tname
                | _ ->
                    let name = mangle_name tname in
                    Format.fprintf fmt
                      "@[<hov>type@ %s@ =@ int@]@\n\
                       @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hv>typedef@ \
                       int_TODO@ %S@]@]@\n\
                       @\n"
                      name name name tname)
            | TPtr ((TFun (retyp, args, _variadic, _) as tfun), _) ->
                Hashtbl.add defined_funcs tfun tname;
                let name = mangle_name tname in
                Format.fprintf fmt
                  "@[<hov 2>type@ %s@ =@ @[<hov>%a -> %a@]@]@\n\
                   @[<hov 2>let@ %s@ :@ %s@ typ@ =@ @[<hov 2>typedef@ @[<hov \
                   2>(Foreign.funptr@ (%a @-> returning %a))@]@ %S@]@]@\n\
                   @\n"
                  name
                  (pp_ocaml_types ~mod_name:false)
                  args
                  (pp_ocaml_type ~mod_name:false)
                  retyp name name
                  (pp_ctypes_types ~in_bindings:false ~lift:false
                     ~mod_name:false)
                  args
                  (pp_ctypes_type ~in_bindings:false ~lift:false ~mod_name:false)
                  retyp tname
            | TPtr _ ->
                let name = mangle_name tname in
                Format.fprintf fmt
                  "@[<hov 2>type@ %s@ =@ %a@]@\n\
                   @[<hov 2>let@ %s@ :@ %s@ typ@ = @[<hov 2>typedef@ %a@ %S@]@]@\n\
                   @\n"
                  name
                  (pp_ocaml_type ~mod_name:false)
                  ttype name name
                  (pp_ctypes_type ~in_bindings:false ~lift:false ~mod_name:false)
                  ttype tname
            | TNamed ({ tname = dest_type; ttype; _ }, _) ->
                let name = mangle_name tname in
                let dest_name = mangle_name dest_type in
                Format.fprintf fmt
                  "@[<hov 2>type@ %s@ =@ %s@]@\n\
                   @[<hov 2>let@ %s@ :@ %s%a@ typ@ =@ @[<hov>typedef@ %s@ \
                   %S@]@]@\n\
                   @\n"
                  name dest_name name name pp_suffix ttype dest_name tname
            | _ -> ())
      | _ -> ())
    globals

let pp_base fmt globals =
  Format.fprintf fmt
    "@[<hov>open@ Ctypes@]@\n\
     @[<hov>open@ Cimgui_types@]@\n\
     @[<hov 2>@[<hov>module@ Base@ (S@ :@ Ctypes.TYPE)@ =@ struct@]@\n\
     @[<hov>open@ S@]@\n\
     %a@]@\n\
     end"
    pp_base_modules globals

let current_module = ref None

let get_module_name_opt name =
  let regexp = Str.regexp "^Im[A-Z][a-zA-Z0-9]*_" in
  let slices = Str.full_split regexp name in
  match slices with Str.Delim mod_ :: _ -> Some mod_ | _ -> None

let mangle_ig_name name =
  String.sub name 2 (String.length name - 2)
  |> camlCase_to_snake_case ~remove_:true

let pp_fun_name curr_mod fmt vname =
  match curr_mod with
  | None ->
      let name = mangle_ig_name vname in
      let name =
        match name with
        | "begin" -> "begin_"
        | "end" -> "end_"
        | "float" -> "float_"
        | "int" -> "int_"
        | "ptr" -> "ptr_"
        | s -> s
      in
      Format.fprintf fmt "%s" name
  | Some mod_ ->
      let regexp = Str.regexp mod_ in
      let name =
        Str.global_replace regexp "" vname
        |> camlCase_to_snake_case ~remove_:true
      in
      let name =
        match name with
        | "begin" -> "begin_"
        | "end" -> "end_"
        | "float" -> "float_"
        | "int" -> "int_"
        | "ptr" -> "ptr_"
        | s -> s
      in
      Format.fprintf fmt "%s" name

let pp_fun_binding fmt var =
  match var with
  | { vname; vtype = TFun _ as vtype; _ }
    when vname <> "ImGuiTextBuffer_appendf" ->
      let module_ = get_module_name_opt vname in
      Format.fprintf fmt "%a@[<hov 2>let@ %a@ =@ @[<hov 2>foreign@ %S@ %a@]@]"
        (fun fmt mod_name ->
          (match (mod_name, !current_module) with
          | None, Some _ -> Format.fprintf fmt "@]@\nend@\n@\n"
          | Some x, Some y when x = y -> Format.fprintf fmt "@\n"
          | Some x, Some y when x <> y ->
              let x =
                if String.ends_with ~suffix:"_" x then
                  String.sub x 0 (String.length x - 1)
                else x
              in
              if x = "ImGuiTextBuffer" then
                Format.fprintf fmt
                  "@[<hov 2>let appendf =@\n\
                   foreign@ \"ImGuiTextBuffer_appendf\"@\n\
                   ((ptr (lift_typ TextBuffer.t)) @-> string @-> returning \
                   void)@]";
              Format.fprintf fmt
                "@]@\nend@\n@\n@[<hov 2>@[<hov>module@ %s@ =@ struct@]@\n" x
          | Some x, None ->
              let x =
                if String.ends_with ~suffix:"_" x then
                  String.sub x 0 (String.length x - 1)
                else x
              in
              Format.fprintf fmt "@\n@[<hov 2>@[<hov>module@ %s@ =@ struct@]@\n"
                x
          | _ -> Format.fprintf fmt "@\n");
          current_module := mod_name)
        module_ (pp_fun_name module_) vname vname
        (pp_ctypes_type ~in_bindings:true ~lift:true ~mod_name:true)
        vtype
  | _ -> ()

let pp_bindings fmt globals =
  Format.fprintf fmt
    "@[<hov>open@ Ctypes@]@\n\
     @[<hov>open@ Cimgui_types@]@\n\
     @[<hov>open@ Cimgui_enums.Enums@ (Cimgui_enums_generated)@]@\n\
     @[<hov>open@ Cimgui_base_structs.Base@ (Cimgui_base_structs_generated)@]@\n\
     @[<hov>open@ Cimgui_structs1@]@\n\
     @[<hov>open@ Cimgui_structs1.Structs@ (Cimgui_structs1_generated)@]@\n\
     @[<hov>open@ Cimgui_structs2@]@\n\
     @[<hov>open@ Cimgui_structs2.Structs@ (Cimgui_structs2_generated)@]@\n\
     @[<hov 2>@[<hov>module@ Bindings@ (F@ :@ Ctypes.FOREIGN)@ =@ struct@]@\n\
     @[<hov 2>open@ F@]@\n\
     %a%a@]@\n\
     end"
    (fun fmt ->
      List.iter (fun global ->
          match global with
          | GVarDecl (({ vtype = TFun _; vname; _ } as var), _)
            when String.starts_with ~prefix:"ig" vname
                 || String.starts_with ~prefix:"Im" vname ->
              current_func := vname;
              pp_fun_binding fmt var
          | _ -> ()))
    globals
    (fun fmt () ->
      if Option.is_some !current_module then Format.fprintf fmt "@]@\nend@\n"
      else ())
    ()

let () =
  let file = Frontc.parse c_file () in
  let globals = file.globals in
  Format.set_geometry ~max_indent:68 ~margin:80;
  (match generator_stage with
  | "types" ->
      pp_header Format.std_formatter;
      Format.fprintf Format.std_formatter "@[<hov>open@ Ctypes@]@\n";
      pp_prolog Format.std_formatter;
      pp_types Format.std_formatter globals
  | "enums" ->
      pp_header Format.std_formatter;
      pp_enums Format.std_formatter globals
  | "base" ->
      stage := 0;
      pp_base Format.std_formatter globals
  | "1" ->
      stage := 1;
      pp_header Format.std_formatter;
      Format.fprintf Format.std_formatter "@[<hov>open@ Ctypes@]@\n";
      Format.fprintf Format.std_formatter "@[<hov>open@ Cimgui_types@]@\n";
      Format.fprintf Format.std_formatter
        "@[<hov>open@ Cimgui_enums.Enums@ (Cimgui_enums_generated)@]@\n\
         @[<hov>open@ Cimgui_base_structs.Base(Cimgui_base_structs_generated)@]@\n\
         @\n";
      pp_structs Format.std_formatter globals
  | "2" ->
      stage := 2;
      pp_header Format.std_formatter;
      Format.fprintf Format.std_formatter "@[<hov>open@ Ctypes@]@\n";
      Format.fprintf Format.std_formatter "@[<hov>open@ Cimgui_types@]@\n";
      Format.fprintf Format.std_formatter
        "@[<hov>open Cimgui_structs1.Structs(Cimgui_structs1_generated)@]@\n\
         @[<hov>open Cimgui_structs1@]@\n";
      Format.fprintf Format.std_formatter
        "@[<hov>open@ Cimgui_enums.Enums@ (Cimgui_enums_generated)@]@\n\
         @[<hov>open@ Cimgui_base_structs.Base(Cimgui_base_structs_generated)@]@\n\
         @\n";
      pp_structs Format.std_formatter globals
  | "bindings" ->
      current_struct := "";
      stage := 3;
      pp_bindings Format.std_formatter globals
  | s -> raise @@ Invalid_argument ("Unknown stage " ^ s));
  if !stage <> 3 then Format.pp_print_flush Format.std_formatter ()
